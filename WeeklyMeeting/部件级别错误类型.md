部件级别错误类型

错误类型 	| 错误类型解释 		| 错误编号 		|  典型汉字 		| 返回值
------------|-------------------|---------------|-------------------|---------
水平平齐 	| 人字底部水平 		| A0001 		| 人 				| A0001:
重心平稳 	| 人字交叉点 		| A0002 		| 人 				| A0002:
黄金分割 	| 					| A0003 		| 人  				| A0003:
首点居正 	| 主的首点 			| A0004 		| 主 文				| A0004
横笔等距 	| 三 横笔划之间等距 | A0005 		| 三 主 			| A0005:
竖笔等距  	| 卅 竖直笔画 		| A0006  		| 卅 山				| A0006:
左右对称    | 主左右对称        | A0007 		| 主 火				| A0007:
横笔等长    | 口 两个横笔等长度 | A0008  	 	| 口 				| A0008:
竖笔等长 	| 竖笔划等长度  	| A0009 		| 口 				| A0009: 
横平竖直    | 主笔              | A0010         | 下 士             | A0010:

笔画级别错误类型定义

错误类型   |  错误类型解释    |  错误编号      |  返回值 
-----------|------------------|----------------|------------
笔画写错   | 笔画写成其他笔画 | B0001 		   | 
笔画位置错误| 笔画的位置发生错误 |  B0002      |

汉字级别错误类型定义, 待定

错误类型   |  错误类型解释    |  错误编号      |  返回值 
-----------|------------------|----------------|------------
左右错位   | 左右结构汉字 错位 | C0001 		   |  C0001


返回值类型

在以前的版本中返回值为两位，（这里隐藏一个BUG，JudgeManager::getResult,返回值有4位，而事实上只需要前两位即可，需要在LUA中约定）。如果修改API为传递其它字符串，是否考虑采用JSON格式，而非选用 `A0001:-strokecount-point,-strokecount-point` 类似字串。

采用如下方式：

	{
		"ret":"101",
	    "error": [
		{
		  "errortype": "A0001",
		  "errorstroke": {"0":"0.2", "1":"0.3"}
		},
		{
		  "errortype": "A0021",
		  "errorstroke": {"0":"0.2", "1":"0.3"}
		}
	  ]
	}

ret 字串内容，评判内容在每一笔完成之后返回，每次返回内容包含该笔画的错误，或者一个部件完成之后的部件正确与否的结果。

ret 字串返回值,一共有3位，每一位对应关系如下： 0 表示错误 ，1 表示正确

- 第一位 表示该笔画是否正确

	其中可能产生笔画错误，或者笔画位置错误，两种错误类型
	
- 第二位 表示该笔画完成之后部件是否正确，如果部件未完成,默认为1正确

	如果第二位出现0，则会产生部件的错误，部件的错误类型如上定义
	
- 第三位 表示该笔画完成，整个汉字正确，默认如果整个汉字未完成，默认为1正确，

传递error数组，包含错误列表，每种错误中包含 `errortype` , `errorstroke` , 两种错误具体错误。如果包含更多错误则继续在error中添加错误列表项。 

举例：

例子1：

	{
	    "ret":"111",
	    "error": []
	}

该笔画没有错误，并且部件错误没有发现,整字未发生错误

例子2：

	{
		"ret":"011",
		"error":[
			{
				"errortype": "B0001",
				"errorstroke":{"null":null}
				"errorstroke":{"null":null}
			}
		]
	}

该笔画发生错误，该笔画的错误类型为 B0001，为该笔画写错。如果 B0002 则表示为笔画位置出现错误。

例子3：

	{
		"ret":"101",
	    "error": [
		{
		  "errortype": "A0001",
		  "errorstroke": {"0":"0.2", "1":"0.3"}
		},
		{
		  "errortype": "A0021",
		  "errorstroke": {"0":"0.2", "1":"0.3"}
		}
	  ]
	}

该笔画没有错误，但是部件发生错误，发生两个错误，分别是 A0001，A0021，错误具体笔画保存在 errorstroke 中。但是这样会遇到一个问题，当错误类型中包含着笔段信息的时候，如何返回 errorstroke 值。

这里舍弃了 errorpoint ,将 errorpoint 值提到 errorstroke 层级，使用 hash 将笔画对应的错误点信息关联起来。

例子4：

	{
		"ret":"110",
		"error": [
		{
			"errortype": "C0001",
			"errorstroke": {"null":null }
		}
		]
	}

整字出现错误，该返回值只可能在整个汉字写完之后出现，返回该汉字的错误类型为 C0001，表示汉字左右部首发生错误。


例子1：

	{
	    "ret":"111",
	    "error": []
	}

该笔画没有错误，并且部件错误没有发现,整字未发生错误

例子2：

	{
		"ret":"011",
		"error":[
			{
				"errortype": "B0001",
				"errorstroke":{"null":null}
				"rightpos":{"null":null}
			}
		]
	}
	
例子3：


	{
		"ret":"101",
	   	 "error": [
			  {
		 		 "errortype": "A0001",
		 		 "errorstroke": {"0":"0.2", "1":"0.3"}
				 "rightpos": {"0":"0.5", "1":"0.7"}
			  },
	
	         ]
	}


	{
		"ret":"110",
		"error": [
			 {
			"errortype": "C0001",
			"errorstroke": {"null":null }
			"rightpos":{"null":null}
			 }
		]
	}
## Lua encode JSON

可选择如下：

- http://www.kyne.com.au/~mark/software/lua-cjson.php
- http://regex.info/blog/lua/json
- 更多选择： <http://lua-users.org/wiki/JsonModules>

cjson 配置：http://www.himigame.com/lua-game/1337.html

## C++ decode JSON

- jsoncpp <https://github.com/open-source-parsers/jsoncpp>
- rapidjson <https://github.com/miloyip/rapidjson>
- boost
- http://blog.csdn.net/hzyong_c/article/details/7163589
